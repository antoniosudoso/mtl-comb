setwd('../')

source("getM4.R")
source("baseForecasters.R")
source("runForecast.R")
source("metrics.R")

library(corrplot)
library(Matrix)
library(quadprog)

# FREQUENCY
# yearly 1
# quarterly 4
# monthly 12
# weekly 4
# daily 7
# hourly 24

# solve QP feature selection problem
get_label_weights <- function(df_errors, id, n_methods, plot=TRUE) {
  n <- n_methods
  # Calculate the correlation matrix with error handling
  Dmat_or <- tryCatch({
    cor(t(df_errors[[id]]$perc_errors))
  }, warning = function(e) {
    diag(n)
  })
  if (is.nan(sum(df_errors[[id]]$sOWA)) || is.nan(sum(df_errors[[id]]$perc_errors)) || is.infinite(sum(df_errors[[id]]$perc_errors))) {
    # relevance vector is not defined
    print(sprintf("Series %d relevance not defined", id))
    return (rep(1.0, n))
  }
  if (norm(Dmat_or - diag(n)) == 0) {
    # correlation matrix is not defined
    print(sprintf("Series %d correlation not defined", id))
    return (rep(1.0, n))
  }
  Dmat <- nearPD((Dmat_or), corr=TRUE)$mat
  dvec <- -as.numeric((df_errors[[id]]$sOWA)/(max(df_errors[[id]]$sOWA))) #sOWA between [0, 1]
  alpha <- (sum((abs(Dmat)))/(n*n)) / ((sum(abs(Dmat))/(n*n)) + (sum((abs(dvec)))/n))
  #print(alpha)
  Amat <- rbind(t(rep(1, n)), diag(n))
  bvec <- c(1, rep(0, n))
  p <- solve.QP((1-alpha)*Dmat,(alpha)*dvec,t(Amat),bvec=bvec,meq=1)
  x <- p$solution
  x[x < 1e-6] <- 0
  if (plot) {
    print(x)
    print(df_errors[[id]]$sOWA)
  }
  if (plot) {
    cc <- cor(t(df_errors[[id]]$perc_errors))
    corrplot(cc, tl.col="black", method='number')
  }
  
  return (x)
  
}

# returns matrix of weights (the i-th row contains the labels of the i-th time series)
compute_label_weights <- function(df_errors) {
  methods <- c('arima', 'ets', 'nnetar', 'tbats', 'stlm', 'rw', 'theta', 'naive', 'snaive')
  n_methods <- length(methods)
  label_matrix <- matrix(NA, nrow=length(df_errors), ncol=n_methods)
  for (i in 1:length(df_errors)) {
    print(i)
    if (i %% 1000 == 0)
      print(i)
    label_matrix[i, ] <- get_label_weights(df_errors, i, n_methods, plot=FALSE)
  }
  return (label_matrix)
}


##################################### MAIN #####################################

SERIES_TYPE <- "Hourly"

# list of series with fields: (id, ts_train, ts_test, mat_forecast, perc_errors, sOWA) generated by 'mainMetrics.R'
df_errors <- readRDS(file=paste0(paste0("./LargeST/data/raw_labels_", SERIES_TYPE), ".rds"))

print(length(df_errors))
m <- compute_label_weights(df_errors)
saveRDS(m, file=paste0(paste0("./LargeST/data/qp_weights_", SERIES_TYPE), ".rds"))

# obtain hard labels from soft labels
tau <- 0.1 # adapt this threshold
m_labels <- m
m_labels[m_labels > tau] <- 1
m_labels[m_labels <= tau] <- 0
print(round(colSums(m_labels)/nrow(m_labels)*100, 2))

saveRDS(m_labels, file=paste0(paste0("./LargeST/data/qp_labels_", SERIES_TYPE), ".rds"))
